<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Skeleton Runes</title>
    <style>
      :root {
        color-scheme: dark;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #111;
        color: #2a2a2a;
      }

      main {
        margin: 0 auto;
        padding: 3rem clamp(1.5rem, 8vw, 6.25rem) 6rem;
      }

      h1 {
        margin: 0 0 2.5rem;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.18em;
      }

      section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2rem;
      }

      aside.rune-filter {
        width: min(520px, 100%);
        display: flex;
        justify-content: center;
      }

      .rune-filter input {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: #f8f8f8;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        outline: none;
        transition: border-color 140ms ease, box-shadow 140ms ease, background 140ms ease;
      }

      .rune-filter input::placeholder {
        color: rgba(248, 248, 248, 0.55);
      }

      .rune-filter input:focus {
        border-color: rgba(241, 196, 15, 0.65);
        background: rgba(241, 196, 15, 0.12);
        box-shadow: 0 0 0 3px rgba(241, 196, 15, 0.2);
      }

      article.runes-grid {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 1.5rem;
      }

      .rune-card {
        background: #1c1c1c;
        border-radius: 12px;
        padding: 0.95rem 0.75rem 1.2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.7rem;
        text-align: center;
        box-shadow: 0 18px 32px rgba(0, 0, 0, 0.28);
        cursor: pointer;
        transition: transform 140ms ease, box-shadow 140ms ease, border 140ms ease;
        border: 2px solid transparent;
      }

      .rune-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 22px 48px rgba(0, 0, 0, 0.35);
        border-color: rgba(241, 196, 15, 0.7);
      }

      .rune-card img {
        width: min(75%, 120px);
        aspect-ratio: 1;
        object-fit: contain;
      }

      .rune-card span {
        font-size: 0.85rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .selection-bar {
        position: fixed;
        inset: auto 0 0;
        background: rgba(20, 20, 20, 0.95);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding: 1.25rem clamp(1.5rem, 8vw, 6.25rem) 1.5rem;
        display: none;
        align-items: center;
        justify-content: center;
        box-shadow: 0 -18px 36px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(8px);
      }

      .selection-bar.is-active {
        display: flex;
      }

      .selection-controls {
        position: absolute;
        top: 0.35rem;
        right: 0.9rem;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.6rem;
      }

      .selection-close {
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.08);
        color: #f8f8f8;
        font-size: 1.25rem;
        font-family: inherit;
        line-height: 1;
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: background 140ms ease, border-color 140ms ease;
      }

      .selection-close:hover {
        background: rgba(241, 196, 15, 0.18);
        border-color: rgba(241, 196, 15, 0.6);
      }

      .selection-close:disabled {
        opacity: 0.45;
        cursor: default;
      }

      .selection-copy {
        min-width: 5.8rem;
        padding: 0.42rem 0.95rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.08);
        color: #f8f8f8;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        font-size: 0.66rem;
        font-family: inherit;
        cursor: pointer;
        transition: background 140ms ease, border-color 140ms ease, color 140ms ease;
      }

      .selection-copy:hover {
        background: rgba(241, 196, 15, 0.18);
        border-color: rgba(241, 196, 15, 0.6);
      }

      .selection-copy:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .selection-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.9rem;
        justify-content: center;
        width: 100%;
        max-width: 960px;
      }

      .selection-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
        padding: 0.35rem 0.5rem;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: 0.75rem;
        min-width: 72px;
        cursor: grab;
        transition: border-color 140ms ease, background 140ms ease, opacity 140ms ease;
      }

      .selection-item:hover {
        border-color: rgba(241, 196, 15, 0.55);
        background: rgba(241, 196, 15, 0.12);
      }

      .selection-item:active {
        cursor: grabbing;
      }

      .selection-item.dragging {
        opacity: 0.6;
        border-color: rgba(241, 196, 15, 0.55);
      }

      .selection-item img {
        width: 36px;
        height: 36px;
        object-fit: contain;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Skeleton Runes</h1>
      <section>
        <aside class="rune-filter">
          <input id="rune-filter-input" type="search" placeholder="Filter runes..." aria-label="Filter runes by word" autocomplete="off" spellcheck="false">
        </aside>
        <article class="runes-grid"></article>
      </section>
    </main>

    <div class="selection-bar" aria-live="polite">
      <div class="selection-controls">
        <button class="selection-close" type="button" aria-label="Clear all runes">&times;</button>
        <button class="selection-copy selection-copy--image" type="button" aria-label="Copy rune images to clipboard">Copy Runes</button>
        <button class="selection-copy selection-copy--text" type="button" aria-label="Copy rune words to clipboard">Copy Text</button>
      </div>
      <div class="selection-list"></div>
    </div>

    <script>
      const runes = [
        { word: 'all', image: 'sr_all.png' },
        { word: 'ancient', image: 'sr_ancient.png' },
        { word: 'beach', image: 'sr_beach.png' },
        { word: 'below', image: 'sr_below.png' },
        { word: 'blade', image: 'sr_blade.png' },
        { word: 'bone', image: 'sr_bone.png' },
        { word: 'cage', image: 'sr_cage.png' },
        { word: 'camp', image: 'sr_camp.png' },
        { word: 'captain', image: 'sr_captain.png' },
        { word: 'cave', image: 'sr_cave.png' },
        { word: 'chalice', image: 'sr_chalice.png' },
        { word: 'chest', image: 'sr_chest.png' },
        { word: 'crew', image: 'sr_crew.png' },
        { word: 'curse', image: 'sr_curse.png' },
        { word: 'death', image: 'sr_death.png' },
        { word: 'dig', image: 'sr_dig.png' },
        { word: 'east', image: 'sr_east.png' },
        { word: 'eternity', image: 'sr_eternity.png' },
        { word: 'face', image: 'sr_face.png' },
        { word: 'five', image: 'sr_five.png' },
        { word: 'flame', image: 'sr_flame.png' },
        { word: 'for', image: 'sr_for.png' },
        { word: 'fortress', image: 'sr_fortress.png' },
        { word: 'four', image: 'sr_four.png' },
        { word: 'from', image: 'sr_from.png' },
        { word: 'ghost_phantom', image: 'sr_ghost_phantom.png' },
        { word: 'glory', image: 'sr_glory.png' },
        { word: 'gold', image: 'sr_gold.png' },
        { word: 'heart', image: 'sr_heart.png' },
        { word: 'hit', image: 'sr_hit.png' },
        { word: 'inside', image: 'sr_inside.png' },
        { word: 'king', image: 'sr_king.png' },
        { word: 'kingdom', image: 'sr_kingdom.png' },
        { word: 'kraken', image: 'sr_kraken.png' },
        { word: 'life', image: 'sr_life.png' },
        { word: 'lord', image: 'sr_lord.png' },
        { word: 'merfolk', image: 'sr_merfolk.png' },
        { word: 'mountain', image: 'sr_mountain.png' },
        { word: 'north', image: 'sr_north.png' },
        { word: 'northstar', image: 'sr_northstar.png' },
        { word: 'one', image: 'sr_one.png' },
        { word: 'order', image: 'sr_order.png' },
        { word: 'order of souls', image: 'sr_Order_of_Souls.png' },
        { word: 'pirate', image: 'sr_pirate.png' },
        { word: 'reaper', image: 'sr_reaper.png' },
        { word: 'record', image: 'sr_record.png' },
        { word: 'resurrection', image: 'sr_resurrection.png' },
        { word: 'ritual', image: 'sr_ritual.png' },
        { word: 'rock', image: 'sr_rock.png' },
        { word: 'sea', image: 'sr_sea.png' },
        { word: 'seven', image: 'sr_seven.png' },
        { word: 'shark', image: 'sr_shark.png' },
        { word: 'ship', image: 'sr_ship.png' },
        { word: 'silver', image: 'sr_silver.png' },
        { word: 'siren', image: 'sr_siren.png' },
        { word: 'six', image: 'sr_six.png' },
        { word: 'skeleton', image: 'sr_skeleton.png' },
        { word: 'skull', image: 'sr_skull.png' },
        { word: 'sleep', image: 'sr_sleep.png' },
        { word: 'song', image: 'sr_song.png' },
        { word: 'south', image: 'sr_south.png' },
        { word: 'sun', image: 'sr_sun.png' },
        { word: 'sunrise', image: 'sr_sunrise.png' },
        { word: 'sunset', image: 'sr_sunset.png' },
        { word: 'three', image: 'sr_three.png' },
        { word: 'time', image: 'sr_time.png' },
        { word: 'to', image: 'sr_to.png' },
        { word: 'trapped', image: 'sr_trapped.png' },
        { word: 'treasure', image: 'sr_treasure.png' },
        { word: 'tree', image: 'sr_tree.png' },
        { word: 'two', image: 'sr_two.png' },
        { word: 'waking', image: 'sr_waking.png' },
        { word: 'walk', image: 'sr_walk.png' },
        { word: 'water', image: 'sr_water.png' },
        { word: 'west', image: 'sr_west.png' },
        { word: 'when', image: 'sr_when.png' }
      ];

      const grid = document.querySelector('.runes-grid');
      const selectionBar = document.querySelector('.selection-bar');
      const selectionList = document.querySelector('.selection-list');
      const selectionClose = document.querySelector('.selection-close');
      const selectionCopyImage = document.querySelector('.selection-copy--image');
      const selectionCopyText = document.querySelector('.selection-copy--text');
      const filterInput = document.querySelector('#rune-filter-input');
      const selectedRunes = [];
      let isDraggingSentence = false;
      let copyFeedbackTimeoutId = null;

      selectionClose.disabled = true;
      selectionCopyImage.disabled = true;
      selectionCopyText.disabled = true;

      selectionList.addEventListener('dragover', (event) => {
        if (!isDraggingSentence) {
          return;
        }

        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
      });

      selectionList.addEventListener('drop', (event) => {
        if (!isDraggingSentence) {
          return;
        }

        event.preventDefault();
        const from = Number(event.dataTransfer.getData('text/plain'));
        if (Number.isNaN(from)) {
          return;
        }

        const [movedRune] = selectedRunes.splice(from, 1);
        selectedRunes.push(movedRune);
        isDraggingSentence = false;
        renderSelection();
      });

      selectionClose.addEventListener('click', () => {
        if (selectedRunes.length === 0) {
          return;
        }

        const confirmed = window.confirm('Clear all selected runes?');
        if (!confirmed) {
          return;
        }

        selectedRunes.length = 0;
        renderSelection();
      });

      selectionCopyImage.addEventListener('click', async () => {
        if (selectedRunes.length === 0 || selectionCopyImage.disabled) {
          return;
        }

        await copySelectionAsImage();
      });

      selectionCopyText.addEventListener('click', async () => {
        if (selectedRunes.length === 0 || selectionCopyText.disabled) {
          return;
        }

        await copySelectionAsText();
      });

      function loadRuneImage(src) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = () => resolve(image);
          image.onerror = () => reject(new Error(`Failed to load image: ${src}`));
          image.crossOrigin = 'anonymous';
          image.src = src;
        });
      }

      async function copySelectionAsImage() {
        if (typeof ClipboardItem === 'undefined' || !navigator.clipboard || !navigator.clipboard.write) {
          window.alert('Copying images to the clipboard is not supported in this browser.');
          return;
        }

        if (copyFeedbackTimeoutId !== null) {
          window.clearTimeout(copyFeedbackTimeoutId);
          copyFeedbackTimeoutId = null;
        }

        if (selectedRunes.length === 0) {
          return;
        }

        const originalLabel = selectionCopyImage.textContent;
        selectionCopyImage.disabled = true;
        selectionCopyImage.textContent = 'Copyingâ€¦';

        let succeeded = false;

        try {
          const images = await Promise.all(
            selectedRunes.map((index) => loadRuneImage(`images/runes/${runes[index].image}`))
          );

          const maxHeight = Math.max(...images.map((img) => img.naturalHeight), 1);
          const targetHeight = Math.max(1, Math.min(256, maxHeight));
          const scaled = images.map((img) => {
            const naturalHeight = Math.max(1, img.naturalHeight);
            const scale = targetHeight / naturalHeight;
            const width = Math.max(1, Math.round(img.naturalWidth * scale));
            return { img, width };
          });

          const totalWidth = scaled.reduce((sum, { width }) => sum + width, 0) || targetHeight;
          const canvas = document.createElement('canvas');
          canvas.width = totalWidth;
          canvas.height = targetHeight;

          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, totalWidth, targetHeight);

          let offsetX = 0;
          scaled.forEach(({ img, width }) => {
            ctx.drawImage(img, offsetX, 0, width, targetHeight);
            offsetX += width;
          });

          const blob = await new Promise((resolve, reject) => {
            canvas.toBlob((value) => {
              if (value) {
                resolve(value);
              } else {
                reject(new Error('Failed to create image blob'));
              }
            }, 'image/png');
          });

          await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
          succeeded = true;
          selectionCopyImage.textContent = 'Copied!';
        } catch (error) {
          console.error(error);
          window.alert('Unable to copy the rune sentence as an image. Please check clipboard permissions and try again.');
          selectionCopyImage.textContent = originalLabel;
        } finally {
          const hasSelection = selectedRunes.length > 0;

          if (succeeded) {
            copyFeedbackTimeoutId = window.setTimeout(() => {
              if (selectedRunes.length > 0) {
                selectionCopyImage.disabled = false;
                selectionCopyImage.textContent = originalLabel;
              } else {
                selectionCopyImage.disabled = true;
                selectionCopyImage.textContent = originalLabel;
              }
              copyFeedbackTimeoutId = null;
            }, 1400);
          } else {
            selectionCopyImage.disabled = !hasSelection;
            if (hasSelection) {
              selectionCopyImage.textContent = originalLabel;
            }
          }
        }
      }

      async function copySelectionAsText() {
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          window.alert('Copying text to the clipboard is not supported in this browser.');
          return;
        }

        const sentence = selectedRunes
          .map((index) => runes[index].word.replace(/_/g, ' '))
          .join(' ');

        try {
          await navigator.clipboard.writeText(sentence);
          selectionCopyText.textContent = 'Copied!';
          selectionCopyText.disabled = true;

          window.setTimeout(() => {
            if (selectedRunes.length > 0) {
              selectionCopyText.textContent = 'Copy Text';
              selectionCopyText.disabled = false;
            } else {
              selectionCopyText.textContent = 'Copy Text';
              selectionCopyText.disabled = true;
            }
          }, 1000);
        } catch (error) {
          console.error(error);
          window.alert('Unable to copy the rune sentence as text. Please check clipboard permissions and try again.');
        }
      }

      function renderSelection() {
        selectionList.innerHTML = '';

        selectedRunes.forEach((index, selectionPosition) => {
          const rune = runes[index];
          const readableWord = rune.word.replace(/_/g, ' ');

          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'selection-item';
          item.dataset.selectionPosition = String(selectionPosition);
          item.draggable = true;

          const img = document.createElement('img');
          img.src = `images/runes/${rune.image}`;
          img.alt = `${readableWord} rune`;

          const label = document.createElement('span');
          label.textContent = readableWord;

          item.append(img, label);
          selectionList.append(item);

          item.addEventListener('click', () => {
            if (isDraggingSentence) {
              return;
            }

            const confirmed = window.confirm('Remove this rune from the sentence?');
            if (!confirmed) {
              return;
            }

            selectedRunes.splice(selectionPosition, 1);
            renderSelection();
          });

          item.addEventListener('dragstart', (event) => {
            isDraggingSentence = true;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', String(selectionPosition));
            item.classList.add('dragging');
          });

          item.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
          });

          item.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation();

            const from = Number(event.dataTransfer.getData('text/plain'));
            const to = Number(item.dataset.selectionPosition);

            if (Number.isNaN(from) || Number.isNaN(to) || from === to) {
              return;
            }

            const [movedRune] = selectedRunes.splice(from, 1);
            const insertAt = from < to ? to - 1 : to;
            selectedRunes.splice(insertAt, 0, movedRune);

            isDraggingSentence = false;
            renderSelection();
          });

          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            setTimeout(() => {
              isDraggingSentence = false;
            }, 0);
          });
        });

        const hasSelection = selectedRunes.length > 0;
        selectionBar.classList.toggle('is-active', hasSelection);
        selectionClose.disabled = !hasSelection;
        selectionCopyImage.disabled = !hasSelection;
        selectionCopyText.disabled = !hasSelection;
        if (!hasSelection) {
          selectionCopyImage.textContent = 'Copy Runes';
          selectionCopyText.textContent = 'Copy Text';
          if (copyFeedbackTimeoutId !== null) {
            window.clearTimeout(copyFeedbackTimeoutId);
            copyFeedbackTimeoutId = null;
          }
        }
      }

      function renderGrid(filteredRunes = runes) {
        grid.innerHTML = '';

        filteredRunes.forEach(({ word, image, originalIndex }) => {
          const index = typeof originalIndex === 'number' ? originalIndex : runes.findIndex((item) => item.word === word && item.image === image);
          const card = document.createElement('div');
          card.className = 'rune-card';
          card.dataset.index = String(index);

          const img = document.createElement('img');
          img.src = `images/runes/${image}`;
          const readableWord = word.replace(/_/g, ' ');
          img.alt = `${readableWord} rune`;

          const label = document.createElement('span');
          label.textContent = readableWord;

          card.append(img, label);
          grid.append(card);

          card.addEventListener('click', () => {
            selectedRunes.push(index);
            renderSelection();
          });
        });
      }

      renderGrid();

      filterInput.addEventListener('input', (event) => {
        const value = event.target.value.trim().toLowerCase();
        if (!value) {
          renderGrid();
          return;
        }

        const filtered = runes
          .map((item, originalIndex) => ({ ...item, originalIndex }))
          .filter(({ word }) => word.toLowerCase().includes(value));

        renderGrid(filtered);
      });
    </script>
  </body>
</html>
